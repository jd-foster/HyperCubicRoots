
# using HyperCubicRoots
import HyperCubicRoots: HyperCubicRoots, F, solve_real_cubic_roots
# Creates F as an alias for HypergeometricFunctions._₂F₁

import Polynomials
import PolynomialRoots

function test_identity(f1,f2,test_array;tol=10*eps())
    A = f1.(test_array)
    B = f2.(test_array)
    D = abs.(A .- B)
    M = maximum(D)

    return (M < tol), M, argmax(D)
end

aa = 0.5:1e-2:100;

# # Testing on a known case: 
L(z) = log(1+z)/z
G(z) = F(1,1,2,-Complex(z))

test_identity(L,G,aa)

## Cubic-related identity:
P(z) = ∛(1 + z) + ∛(1-z);
H(z) = 2F(-1/6, 1/3, 1/2, Complex(z)^2)

bb = 0:1e-3:0.999

test_identity(H,P,bb, tol=100*eps())

# Note: we need to ensure that |z| < 1 in the argument of F
P(1.01) ≈ H(1.01)  #  isapprox(P(1.01), H(1.01))   false
# (This is done via the Kummer transformation in the cubic roots derivation.)

##
cc = [-72, -36, 0, 1]

p1 = -12
q1 = -36
Del1 = q1^2 + p1^3
s1 = Del1/p1^3

r_num = PolynomialRoots.roots(cc)

r_hyp = [
     2q1/p1*F(1/3, 2/3, 1/2, s1),
   -(2q1/3p1)*F(2/3, 4/3, 3/2, 1/2*(1 + sqrt(s1))),
   -(2q1/3p1)*F(2/3, 4/3, 3/2, 1/2*(1 - sqrt(s1))),
]

r_trig = [
    2*sqrt(12)*cos(  π/18),
    2*sqrt(12)*cos(13π/18),
    2*sqrt(12)*cos(25π/18),
]

# # Leading coefficient is zero:
aa = [-417.47, 843.75, 521.67, 0.0]
try
    rr_hyp = HyperCubicRoots.solve_real_cubic_roots(aa)
catch e
    @warn e
end
    

real_to_tolerance(vec,ϵ) = real.(filter(z -> abs(imag(z)) < ϵ, vec))

# # Three real roots example:
# a = [-23.88, -8.04, 81.02, 13.17]

# # One real roots example:
# a = [81.80, -59.66, -76.47, -64.32]

# # General comparision:
# Compare the roots obtained from PolynomialRoots to this method.

# Notes: the below test compares the numerical roots from PolynomialRoots
# with those generated by the hypergeometric method.
# Experimental observations show that the number of real roots and their
# approximate value are in agreement, 
# when using a tolerance (test_cubic_tol) of 1e-5 or larger.
# However, the evaluation of the roots in the polynomial function indicate that the 
# PolynomialRoots solutions are much more accurate:
# p = Polynomials.Polynomial([-590.92, 213.72, -419.35, 274.27])
# e.g. hypergeometric: p(1.7742160152725672) =  0.00263
#     PolynomialRoots: p(1.7742140121531602) = -3.96224e-13
# The trade-off is that the hypergeometric evaluation is about a factor of 2 faster.
# It may be worth "polishing" the root is greater accuracy is required.

test_cubic_tol = 1e-5
# Notes:
#  1e-5 is experimentally accurate for Float64 calculations
#  1e-15 works for BigFloat calculations, albeit much slower calculations.

test_lead_zero_tol = 1e-8
# test_lead_zero_tol = big"1e-8"
test_real_tol = 1e-8
N_iter = 100_000
global count = 0
for i in 1:N_iter
    global count
    a = rand(-1000:0.01:1000,4)  # randomly generate the coefficients of the cubic.
    # a = rand(big"-1000":0.01:big"1000",4)  # randomly generate the coefficients of the cubic: BigFloat
    if abs(a[4]) < test_cubic_tol
        @info("The leading cubic coefficient is approximately zero. Skipping iteration $(i).")
        println("a =", a)
        continue
    end
    # fa = Polynomials.Polynomial(a)
    R_hyp = sort(HyperCubicRoots.solve_real_cubic_roots(a,cubic_tol=test_lead_zero_tol))

    R_num = PolynomialRoots.roots(a)
    R_num_real = sort(real_to_tolerance(R_num,test_real_tol))

    try
        @assert all(isapprox.(sort(R_hyp), sort(R_num_real), atol=test_cubic_tol))
    catch e
        @error e
        println(e)
        println("Coefficients: ")
        println(a)
        println("HyperCubicRoots : R_hyp = ", R_hyp)
        println("PolynomialRoots : R_num = ", R_num_real)
        break
    end 

    if mod(i, N_iter ÷ 10)  == 0 || length(R_hyp) == 3
        length(R_hyp) == 3 && count <= 10 ? (count = count + 1) : continue
        println()
        println("Coefficients: ")
        println(a)
        println("HyperCubicRoots:")
        @show(R_hyp)
        println("PolynomialRoots")
        @show R_num
    end

end

function polyeval(aa, root)
    p = Polynomials.Polynomial(aa)
    return p.(root)
end

# # We see that the accuray of the root degenerates as the leading coefficient
# # becomes smaller. Hence we set the accuracy of the method to about 1e-7.
# TYPE = Float16 # errors due to overflow in calculation.
# TYPE = Float32
TYPE = Float64 
# TYPE = BigFloat
for i in 1.0:1:8.0
    x = convert(Vector{TYPE},[-1.,2.1,-3.2,10^-i])
    p = Polynomials.Polynomial(x)
    r = HyperCubicRoots.solve_real_cubic_roots(x, cubic_tol=TYPE(1e-16))
    println( (i, 10^-i, r[1]))
    println(p(r[1]))
end

# # The relative magnitudes of the polynomial coefficients plays a role here.
# # The various methods from 
for i in 1.0:1:10.0
    x = [-1.,34.1,-34.2,10^-i]
    p = Polynomials.Polynomial(x)
    r = HyperCubicRoots.solve_real_cubic_roots(x, cubic_tol=HyperCubicRoots.CUBIC_ATOL)        
    # r = PolynomialRoots.roots(x)
    # r = PolynomialRoots.solve_cubic_eq(Vector{Complex{Float64}}(x))
    # println(r)
    if !isempty(r)
        println( (i, 10^-i, r[1], p(r[1])))
    end
end

## Timing comparison: 
trials = 1_000_000
@time for _ in 1:trials
    a = rand(0.01:0.01:1000.01,4)
    R_hyp = HyperCubicRoots.solve_real_cubic_roots(a)
end

@time for _ in 1:trials
    a = rand(-1000:0.01:1000.01,4)
    R_num = PolynomialRoots.roots(a)
end